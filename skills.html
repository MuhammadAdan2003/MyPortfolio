<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Circles Simulation</title>
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <style>
      :root {
        --color-black: #111;
        --color-white: #ffffff;
        --color-primary: #10b981;
      }

      body {
        overflow-x: hidden;
        margin: 0;
        padding: 0;
      }

      @font-face {
        font-family: "mazius";
        src: url("mazius_display/MaziusDisplay/Mazius\ Display\ Extraitalic.otf")
          format("opentype");
      }

      @font-face {
        font-family: "gilroy-bold";
        src: url("gilroy-bold/Gilroy-Bold.ttf") format("opentype");
      }

      @font-face {
        font-family: "gilroy";
        src: url("gilroy-bold/Gilroy-Medium.ttf") format("opentype");
      }

      .mazius {
        font-family: "mazius";
      }

      .gilroy-bold {
        font-family: "gilroy-bold";
      }

      .gilroy {
        font-family: "gilroy";
      }

      .bg-primary {
        background-color: var(--color-primary) !important;
      }

      .text-primary {
        color: var(--color-primary) !important;
      }

      #simulation-wrapper {
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: relative;
      }

      #physics-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      #eyes {
        --size: clamp(64px, 30vi, 256px);
        block-size: var(--size);
        inline-size: var(--size);
      }
    </style>
  </head>
  <body class="bg-black">
    <div
      class="fixed top-[2%] lg:w-[40%] bg-[#111111] border-2 border-white text-white rounded-lg lg:rounded-xl left-1/2 -translate-x-1/2 z-50"
    >
      <div class="flex justify-around items-center">
        <span class="p-4 lg:p-5"><a href="index.html">Home</a></span>
        <span class="p-4 lg:p-5"><a href="#">Testimonials</a></span>
        <span class="p-4 lg:p-5"><a href="#">Projects</a></span>
        <span class="p-4 lg:p-5"><a href="skills.html">Skills</a></span>
        <!-- <span class="p-4 lg:p-5">text</span> -->
      </div>
    </div>

    <main data-barba="wrapper">
      <div
        data-barba="container"
        data-barba-namespace="skills"
        class="page-content"
      >
        <!-- Equal grid layout for both sections -->
        <div class="grid grid-cols-1 lg:grid-cols-2 h-screen">
          <!-- LEFT SECTION - Text Content -->
          <div
            class="p-4 md:p-6 lg:p-8 xl:p-10 flex flex-col justify-center h-screen items-center bg-black"
          >
            <svg
              id="eyes"
              width="128"
              height="128"
              viewBox="0 0 128 128"
              role="img"
              aria-label="googly eyes emoji that track the mouse cursor"
            >
              <defs>
                <linearGradient
                  id="a"
                  x1="0"
                  x2="0"
                  y1="46.676"
                  y2="82.083"
                  gradientUnits="userSpaceOnUse"
                >
                  <stop offset="0" style="stop-color: #424242" />
                  <stop offset="1" style="stop-color: #212121" />
                </linearGradient>
                <g id="eye-shape">
                  <path
                    style="fill: #fafafa"
                    d="M34.16 106.51C18.73 106.51 6.19 87.44 6.19 64s12.55-42.51 27.97-42.51S62.13 40.56 62.13 64s-12.55 42.51-27.97 42.51"
                  />
                  <path
                    style="fill: #b0bec5"
                    d="M34.16 23.49c6.63 0 12.98 4 17.87 11.27 5.22 7.75 8.1 18.14 8.1 29.24s-2.88 21.49-8.1 29.24c-4.89 7.27-11.24 11.27-17.87 11.27s-12.98-4-17.87-11.27C11.06 85.49 8.19 75.1 8.19 64s2.88-21.49 8.1-29.24c4.89-7.27 11.23-11.27 17.87-11.27m0-4C17.61 19.49 4.19 39.42 4.19 64s13.42 44.51 29.97 44.51S64.13 88.58 64.13 64 50.71 19.49 34.16 19.49"
                  />
                </g>
                <path
                  id="pupil-shape"
                  style="fill: url(#a)"
                  d="M25.63 59.84c-2.7-2.54-2.1-7.58 1.36-11.26.18-.19.36-.37.55-.54-1.54-.87-3.23-1.36-5.01-1.36-7.19 0-13.02 7.93-13.02 17.7s5.83 17.7 13.02 17.7 13.02-7.93 13.02-17.7c0-1.75-.19-3.45-.54-5.05-3.24 2.33-7.11 2.64-9.38.51"
                />
              </defs>
              <use href="#eye-shape" id="eye-left" />
              <use href="#pupil-shape" id="pupil-left" />
              <g transform="translate(59.68 0)">
                <use href="#eye-shape" id="eye-right" />
                <use href="#pupil-shape" id="pupil-right" />
              </g>
            </svg>
            <div class="max-w-xl mx-auto">
              <!-- Heading -->
              <h1
                class="text-primary text-center mazius text-3xl sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl leading-[1.2] sm:leading-[1.3] md:leading-[1.4] lg:leading-[50px] xl:leading-[55px] mb-4 md:mb-6 lg:mb-8"
              >
                Skills & Stack
              </h1>

              <!-- First paragraph -->
              <p
                class="text-white gilroy font-bold text-base sm:text-lg md:text-xl lg:text-2xl xl:text-3xl leading-[1.3] sm:leading-[1.4] md:leading-[1.5] lg:leading-[1.6] xl:leading-[45px] mb-4 md:mb-6 lg:mb-8"
              >
                From pixels to databases I craft web applications with
                <span class="mazius text-primary">React</span> on the front,
                <span class="text-primary mazius">Laravel</span> on the back,
                and <span class="text-primary mazius">MySQL</span> holding it
                all together
              </p>

              <!-- Second paragraph -->
              <p
                class="text-white gilroy font-bold text-base sm:text-lg md:text-xl lg:text-2xl xl:text-3xl leading-[1.3] sm:leading-[1.4] md:leading-[1.5] lg:leading-[1.6] xl:leading-[45px] mb-4 md:mb-6 lg:mb-8"
              >
                I turn Figma designs into responsive interfaces, connect them to
                real data using <span class="text-primary mazius">APIs</span>,
                and make sure everything works smoothly from UI to backend logic
              </p>
            </div>
          </div>

          <!-- RIGHT SECTION - Simulation -->
          <div class="bg-white h-full">
            <div id="simulation-wrapper" class="w-full h-full">
              <canvas id="physics-canvas"></canvas>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- <script src="script.js"></script> -->

    <script>
      // Module aliases
      const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint;

      // Create engine
      const engine = Engine.create();
      engine.gravity.x = 0;
      engine.gravity.y = 0.2;

      // Get the canvas element and wrapper
      const canvas = document.getElementById("physics-canvas");
      const wrapper = document.getElementById("simulation-wrapper");

      // Create renderer
      const render = Render.create({
        element: wrapper,
        engine: engine,
        canvas: canvas,
        options: {
          width: wrapper.clientWidth,
          height: wrapper.clientHeight,
          wireframes: false,
          background: "#ffffff",
          showVelocity: false,
        },
      });

      // Create runner
      const runner = Runner.create();

      // Arrays to track circles
      let circles = [];
      let bigCircle = null;
      let BIG_CIRCLE_RADIUS;

      // Text options for circles
      const circleTexts = [
        "HTML",
        "CSS",
        "JavaScript",
        "JQuery",
        "React",
        "GSAP",
        "MYSQL",
        "PHP",
        "LARAVEL",
        "GIT",
        "TAILWIND",
        "BOOTSTRAP",
        "UI/UX",
        "APIs",
        "Third API",
        "Animations",
      ];

      // Calculate responsive BIG circle radius
      function calculateCircleRadius() {
        const width = wrapper.clientWidth;
        const height = wrapper.clientHeight;
        const screenWidth = window.innerWidth;

        // Responsive sizing based on device
        if (screenWidth < 640) {
          // Mobile
          return Math.min(width, height) * 0.4; // 50% on mobile
        } else if (screenWidth < 1024) {
          // Tablet
          return Math.min(width, height) * 0.4; // 60% on tablet
        } else {
          // Desktop
          return Math.min(width, height) * 0.4; // 70% on desktop
        }
      }

      // Calculate responsive text size for circles
      function calculateCircleSize() {
        const screenWidth = window.innerWidth;

        if (screenWidth < 640) {
          // Mobile
          return Math.min(30, BIG_CIRCLE_RADIUS / 5);
        } else if (screenWidth < 1024) {
          // Tablet
          return Math.min(35, BIG_CIRCLE_RADIUS / 5);
        } else {
          // Desktop
          return Math.min(55, BIG_CIRCLE_RADIUS / 6);
        }
      }

      // Function to create a small circle with text
      function createSmallCircle(x, y, text) {
        const radius = calculateCircleSize();
        const circle = Bodies.circle(x, y, radius, {
          restitution: 0.7,
          friction: 0.05,
          frictionAir: 0.02,
          density: 0.002,
          render: {
            fillStyle: "#000000",
            lineWidth: 0,
            strokeStyle: "transparent",
          },
        });

        circle.text = text;
        Composite.add(engine.world, circle);
        circles.push(circle);

        return circle;
      }

      // Function to create the big container circle
      function createBigCircle() {
        const canvasWidth = render.options.width;
        const canvasHeight = render.options.height;
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;

        // Recalculate radius
        BIG_CIRCLE_RADIUS = calculateCircleRadius();

        // Create invisible circle for boundary
        bigCircle = Bodies.circle(centerX, centerY, BIG_CIRCLE_RADIUS, {
          isStatic: true,
          isSensor: true,
          render: {
            fillStyle: "transparent",
            strokeStyle: "transparent",
            lineWidth: 0,
          },
        });

        Composite.add(engine.world, bigCircle);
        createCircularBoundary(centerX, centerY, BIG_CIRCLE_RADIUS);

        return bigCircle;
      }

      // Create circular boundary using small wall segments
      function createCircularBoundary(centerX, centerY, radius) {
        const screenWidth = window.innerWidth;
        const segments = screenWidth < 640 ? 36 : 48; // Fewer segments on mobile
        const angleStep = (Math.PI * 2) / segments;

        for (let i = 0; i < segments; i++) {
          const angle = i * angleStep;
          const nextAngle = (i + 1) * angleStep;

          const x1 = centerX + Math.cos(angle) * radius;
          const y1 = centerY + Math.sin(angle) * radius;
          const x2 = centerX + Math.cos(nextAngle) * radius;
          const y2 = centerY + Math.sin(nextAngle) * radius;

          const dx = x2 - x1;
          const dy = y2 - y1;
          const length = Math.sqrt(dx * dx + dy * dy);
          const wallX = (x1 + x2) / 2;
          const wallY = (y1 + y2) / 2;
          const wallAngle = Math.atan2(dy, dx);

          const wallThickness = screenWidth < 640 ? 8 : 12;

          const wall = Bodies.rectangle(wallX, wallY, length, wallThickness, {
            isStatic: true,
            angle: wallAngle,
            render: {
              fillStyle: "transparent",
              strokeStyle: "transparent",
              lineWidth: 0,
            },
          });

          Composite.add(engine.world, wall);
        }
      }

      // Create small circles inside the big circle
      function createSmallCircles() {
        circles.forEach((circle) => {
          Composite.remove(engine.world, circle);
        });
        circles = [];

        const centerX = render.options.width / 2;
        const centerY = render.options.height / 2;
        const screenWidth = window.innerWidth;

        // Adjust number of circles based on screen size
        let maxCircles = circleTexts.length;
        if (screenWidth < 640) {
          maxCircles = 10; // Fewer circles on mobile
        } else if (screenWidth < 1024) {
          maxCircles = 14; // Medium on tablet
        }

        for (let i = 0; i < Math.min(maxCircles, circleTexts.length); i++) {
          let x, y, distance;
          let attempts = 0;
          const minDistance =
            calculateCircleSize() + (screenWidth < 640 ? 15 : 20);

          do {
            x =
              centerX +
              (Math.random() - 0.5) * (BIG_CIRCLE_RADIUS - minDistance) * 1.8;
            y =
              centerY +
              (Math.random() - 0.5) * (BIG_CIRCLE_RADIUS - minDistance) * 1.8;
            distance = Math.sqrt(
              Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2),
            );
            attempts++;
          } while (
            distance > BIG_CIRCLE_RADIUS - minDistance &&
            attempts < 100
          );

          createSmallCircle(x, y, circleTexts[i]);
        }
      }

      // Add mouse control
      const mouse = Mouse.create(render.canvas);
      const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
          stiffness: 0.1,
          render: { visible: false },
        },
      });

      Composite.add(engine.world, mouseConstraint);
      render.mouse = mouse;

      // Track screen width for responsive calculations
      let screenWidth = window.innerWidth;

      // Handle hover effect
      function handleHoverEffect() {
        const mousePosition = mouse.position;

        circles.forEach((circle) => {
          const dx = mousePosition.x - circle.position.x;
          const dy = mousePosition.y - circle.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const hoverRadius =
            circle.circleRadius + (screenWidth < 640 ? 20 : 30);

          if (distance < hoverRadius) {
            const forceMagnitude = screenWidth < 640 ? 0.006 : 0.008;
            const force = {
              x: (circle.position.x - mousePosition.x) * forceMagnitude,
              y: (circle.position.y - mousePosition.y) * forceMagnitude,
            };
            Matter.Body.applyForce(circle, circle.position, force);
          }
        });
      }

      // Custom rendering
      Matter.Events.on(render, "afterRender", function () {
        const context = render.context;
        const centerX = render.options.width / 2;
        const centerY = render.options.height / 2;

        // Draw big circle outline
        context.save();
        context.beginPath();
        context.arc(centerX, centerY, BIG_CIRCLE_RADIUS, 0, Math.PI * 2);
        context.strokeStyle = "rgba(0, 0, 0, 0.8)";
        context.lineWidth = screenWidth < 640 ? 4 : 6;
        context.stroke();
        context.restore();

        // Draw each small circle with text
        circles.forEach((circle) => {
          const position = circle.position;
          const radius = circle.circleRadius;

          context.save();
          context.translate(position.x, position.y);

          // Draw circle
          context.beginPath();
          context.arc(0, 0, radius, 0, Math.PI * 2);
          context.fillStyle = "#000000";
          context.fill();

          // Draw text with Gilroy font
          context.fillStyle = "#FFFFFF";
          let fontSize = Math.max(
            screenWidth < 640 ? 10 : 12,
            radius / (screenWidth < 640 ? 2.0 : 1.8),
          );

          // Use Gilroy font
          context.font = `600 ${fontSize}px 'gilroy', Arial, sans-serif`;
          context.textAlign = "center";
          context.textBaseline = "middle";

          const maxWidth = radius * (screenWidth < 640 ? 1.4 : 1.6);
          while (
            context.measureText(circle.text).width > maxWidth &&
            fontSize > (screenWidth < 640 ? 8 : 10)
          ) {
            fontSize -= 1;
            context.font = `600 ${fontSize}px 'gilroy', Arial, sans-serif`;
          }

          context.fillText(circle.text, 0, 0);
          context.restore();
        });

        handleHoverEffect();
      });

      // Handle window resize
      let resizeTimeout;
      function handleResize() {
        screenWidth = window.innerWidth;

        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const wrapperWidth = wrapper.clientWidth;
          const wrapperHeight = wrapper.clientHeight;

          render.options.width = wrapperWidth;
          render.options.height = wrapperHeight;
          render.canvas.width = wrapperWidth;
          render.canvas.height = wrapperHeight;

          Composite.clear(engine.world);
          circles = [];
          bigCircle = null;

          createBigCircle();
          createSmallCircles();
          Composite.add(engine.world, mouseConstraint);
        }, 100);
      }

      // Initialize simulation
      function init() {
        screenWidth = window.innerWidth;
        createBigCircle();
        createSmallCircles();
        Runner.run(runner, engine);
        Render.run(render);
      }

      // Start simulation
      window.addEventListener("load", () => {
        handleResize();
        init();
      });

      window.addEventListener("resize", handleResize);

      // Prevent canvas from interfering with scrolling
      canvas.addEventListener("wheel", (e) => {
        e.stopPropagation();
      });

      // Handle orientation change
      window.addEventListener("orientationchange", () => {
        setTimeout(handleResize, 100);
      });

      const eyesSVG = document.querySelector("#eyes");
      const eyes = [
        {
          eye: eyesSVG.querySelector("#eye-left"),
          pupil: eyesSVG.querySelector("#pupil-left"),
          offsetX: 0,
        },
        {
          eye: eyesSVG.querySelector("#eye-right"),
          pupil: eyesSVG.querySelector("#pupil-right"),
          offsetX: 0,
        },
      ];

      const updateEye = (ev, { eye, pupil, offsetX }) => {
        const eyeRect = eye.getBoundingClientRect();
        const centerX = eyeRect.left + eyeRect.width / 2;
        const centerY = eyeRect.top + eyeRect.height / 2;

        const distX = ev.clientX - centerX;
        const distY = ev.clientY - centerY;

        const pupilRect = pupil.getBoundingClientRect();
        const maxDistX = pupilRect.width / 2;
        const maxDistY = pupilRect.height / 2;

        const angle = Math.atan2(distY, distX);

        const newPupilX =
          offsetX +
          Math.min(maxDistX, Math.max(-maxDistX, Math.cos(angle) * maxDistX));
        const newPupilY = Math.min(
          maxDistY,
          Math.max(-maxDistY, Math.sin(angle) * maxDistY),
        );

        const svgCTM = eyesSVG.getScreenCTM();
        const scaledPupilX = newPupilX / svgCTM.a;
        const scaledPupilY = newPupilY / svgCTM.d;

        pupil.setAttribute(
          "transform",
          `translate(${scaledPupilX}, ${scaledPupilY})`,
        );
      };

      // Pupil position starts off-centre on the X axis
      const calcOffset = () => {
        for (const props of eyes) {
          props.pupil.removeAttribute("transform");
          const eyeRect = props.eye.getBoundingClientRect();
          const pupilRect = props.pupil.getBoundingClientRect();
          props.offsetX =
            (eyeRect.right -
              pupilRect.right -
              (pupilRect.left - eyeRect.left)) /
            2;
        }
      };
      calcOffset();

      globalThis.addEventListener("resize", () => {
        calcOffset();
      });

      let frame = 0;
      globalThis.addEventListener("mousemove", (ev) => {
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => {
          for (const eye of eyes) {
            updateEye(ev, eye);
          }
        });
      });
    </script>
  </body>
</html>
